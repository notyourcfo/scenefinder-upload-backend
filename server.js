const express = require('express');
const multer = require('multer');
const { OpenAI } = require('openai');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const { google } = require('googleapis');

require('dotenv').config();

const app = express();
const upload = multer({ 
  dest: 'uploads/',
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

// Initialize OpenAI client
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Middleware
app.use(cors());
app.use(express.json());

// Ensure uploads directory exists
const uploadDir = path.join(__dirname, 'uploads');
try {
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }
} catch (error) {
  console.error('Failed to create uploads directory:', error);
  process.exit(1);
}

// Health check endpoint
app.get('/', (req, res) => {
  res.status(200).json({ status: 'OK', message: 'SceneFinder backend is running' });
});

// SerpAPI setup
const SERPAPI_KEY = process.env.SERPAPI_KEY;
const SERPAPI_BASE_URL = 'https://serpapi.com/search';

// YouTube API setup (for fetching transcripts)
const YOUTUBE_BASE_URL = 'https://www.googleapis.com/youtube/v3';

// Initialize OAuth 2.0 client for YouTube API
const oauth2Client = new google.auth.OAuth2(
  process.env.YOUTUBE_CLIENT_ID,
  process.env.YOUTUBE_CLIENT_SECRET,
  process.env.YOUTUBE_REDIRECT_URI
);

// Set credentials with refresh token
oauth2Client.setCredentials({
  refresh_token: process.env.YOUTUBE_REFRESH_TOKEN,
});

// Automatically refresh token when needed
oauth2Client.on('tokens', (tokens) => {
  if (tokens.access_token) {
    console.log('New access token:', tokens.access_token);
  }
});

// Function to search web and YouTube using SerpAPI
const searchWebAndYoutube = async (query) => {
  try {
    console.log('SerpAPI Query:', query);
    const searchResponse = await axios.get(SERPAPI_BASE_URL, {
      params: {
        api_key: SERPAPI_KEY,
        q: query,
        engine: 'google',
        num: 5,
      },
    });

    const results = searchResponse.data.organic_results || [];
    console.log('SerpAPI Results:', results);

    // Filter for YouTube results
    const youtubeResults = results.filter(result => result.link.includes('youtube.com/watch'));
    if (!youtubeResults.length) {
      return JSON.stringify({ results: [] });
    }

    // Process the top YouTube result
    const topResult = youtubeResults[0];
    const videoIdMatch = topResult.link.match(/v=([^&]+)/);
    const videoId = videoIdMatch ? videoIdMatch[1] : null;

    let transcript = 'Transcript not fetched.';
    if (videoId) {
      // Fetch transcript using YouTube API with OAuth 2.0
      try {
        const youtube = google.youtube({
          version: 'v3',
          auth: oauth2Client,
        });

        // Fetch available captions
        const captionsResponse = await youtube.captions.list({
          part: 'snippet',
          videoId: videoId,
        });

        const captions = captionsResponse.data.items;
        const englishCaption = captions.find(caption => 
          caption.snippet.language === 'en' || caption.snippet.language === 'en-US'
        );

        if (englishCaption) {
          // Check if the caption is auto-generated
          const isAutoGenerated = englishCaption.snippet.trackKind === 'asr';
          console.log(`Caption for Video ID ${videoId}: Language=${englishCaption.snippet.language}, Auto-generated=${isAutoGenerated}`);

          if (isAutoGenerated) {
            transcript = 'Auto-generated captions are not downloadable by third parties.';
          } else {
            // Attempt to fetch the caption track if not auto-generated
            try {
              const captionTrackResponse = await youtube.captions.download({
                id: englishCaption.id,
                tfmt: 'vtt',
              });

              const vttText = captionTrackResponse.data;
              transcript = vttText
                .split('\n')
                .filter(line => !line.match(/^(WEBVTT|Kind:|Language:|\d+\n\d{2}:\d{2}:\d{2}\.\d{3} --> \d{2}:\d{2}:\d{2}\.\d{3})/))
                .filter(line => line.trim() !== '')
                .join(' ');
              console.log('YouTube Transcript for Video ID', videoId, ':', transcript);
            } catch (downloadError) {
              console.error('Error downloading YouTube transcript:', downloadError.message);
              transcript = `Unable to download transcript: ${downloadError.message}`;
            }
          }
        } else {
          transcript = 'No English captions available.';
        }
      } catch (error) {
        console.error('Error fetching YouTube transcript:', error.message);
        transcript = 'Error fetching transcript.';
      }
    }

    return JSON.stringify({
      results: [{
        title: topResult.title,
        link: topResult.link,
        snippet: topResult.snippet,
        video_id: videoId,
        transcript: transcript,
      }]
    });
  } catch (error) {
    console.error('SerpAPI error:', error.message);
    if (error.response && (error.response.status === 403 || error.response.status === 429)) {
      console.log('SerpAPI quota likely exhausted. Skipping SerpAPI search.');
      return JSON.stringify({ quota_exhausted: true });
    }
    return JSON.stringify({ results: [] });
  }
};

// Upload endpoint
app.post('/api/upload', upload.single('video'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No video file uploaded' });
    }

    console.log('Uploaded file:', {
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: req.file.path
    });

    const allowedTypes = ['video/mp4', 'video/quicktime', 'audio/mpeg', 'audio/mp4', 'audio/wav', 'audio/flac', 'audio/ogg', 'video/webm'];
    if (!allowedTypes.includes(req.file.mimetype)) {
      fs.unlinkSync(req.file.path);
      return res.status(400).json({ error: `Invalid file type. Only MP4, MOV, MP3, M4A, WAV, FLAC, OGG, and WEBM are supported. Got: ${req.file.mimetype}` });
    }

    const originalExt = path.extname(req.file.originalname).toLowerCase();
    const tempFilePath = path.join(uploadDir, `temp-${Date.now()}${originalExt}`);
    fs.renameSync(req.file.path, tempFilePath);

    const transcription = await openai.audio.transcriptions.create({
      file: fs.createReadStream(tempFilePath),
      model: 'whisper-1',
    });
    console.log('Whisper Transcription:', transcription.text);

    fs.unlinkSync(tempFilePath);

    const tools = [
      {
        type: 'function',
        function: {
          name: 'search_web_and_youtube',
          description: 'Search the web and YouTube using a query string to find matching videos or content.',
          parameters: {
            type: 'object',
            properties: {
              query: {
                type: 'string',
                description: 'The query string to search for, such as dialogue snippets with context (e.g., "put it in my box Amanda Cerny site:youtube.com").',
              },
            },
            required: ['query'],
          },
        },
      },
    ];

    const initialPrompt = `
      You are a movie analyst with expertise in identifying scenes from short video or audio clips. Given the following dialogue transcript, analyze it and provide scene details in the exact JSON format specified below. Try to identify the scene based on your knowledge alone, without using any external tools. If you cannot identify the movie or series with high confidence (e.g., if the movie or series is "Unknown"), indicate this clearly. It is critical to identify at least the movie or series name if possible. If other details like characters or timestamp are unclear, provide your best guess or mark them as "Unknown". Focus on modern films or series (post-2000) with comedic, adventurous, or lighthearted elements, especially those set in environments like summer camps, schools, workplaces, or events where misunderstandings or casual banter might occur. If the transcript is unclear, make an educated guess based on tone, context, and keywords, or return "Unknown" for unidentifiable fields.

      **Required JSON Format:**
      {
        "movie_or_series": "<movie or series name, or 'Unknown' if not identifiable>",
        "season": <season number as integer, or null if not a series or unknown>,
        "episode": <episode number as integer, or null if not a series or unknown>,
        "characters": [<array of character names as strings, or "Unknown" if not identifiable>],
        "timestamp": "<approximate timestamp in 'Approx. HH:MM:SS' format, or 'Unknown' if not identifiable>",
        "context_or_summary": "<brief summary of the scene, including its role in the story, or a best guess>"
      }

      **Transcript:**
      ${transcription.text}
    `;

    let messages = [{ role: 'user', content: initialPrompt }];
    let initialGptResponse = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: messages,
      response_format: { type: 'json_object' },
    });

    console.log('Initial GPT-4o Response (No Tools):', initialGptResponse.choices[0].message);

    let sceneDetails = JSON.parse(initialGptResponse.choices[0].message.content);

    if (sceneDetails.movie_or_series === 'Unknown') {
      console.log('GPT-4o could not identify the movie name. Falling back to SerpAPI search.');

      const fallbackPrompt = `
        You are a movie analyst with expertise in identifying scenes from short video or audio clips. Given the following dialogue transcript, you were unable to identify the scene with high confidence. Now, use the provided tool (search_web_and_youtube) to search the web and YouTube for videos or content matching the dialogue. You MUST construct a query with the key dialogue snippet "put it in my box", include the known actor "Amanda Cerny", and add context like "summer camp" to narrow down the search (e.g., "put it in my box Amanda Cerny summer camp site:youtube.com"). If the initial search returns no relevant results, try a broader query like "Amanda Cerny summer camp movie scene site:youtube.com". Parse the search results to identify the movie, scene, characters, and timestamp. Prioritize the video title as the primary source of information for identifying the movie or series, as it often contains the most direct reference to the content (e.g., a title like "Rim Of The World Amanda Cerny" clearly indicates the movie "Rim of the World"). If the transcript is not available or cannot be fetched, rely on the video title first, then the snippet, to make an educated guess about the movie and scene—do not return "Unknown" for the movie_or_series field unless both the title and snippet provide no useful information about a movie or series. Focus on modern films or series (post-2000) with comedic, adventurous, or lighthearted elements, especially those set in environments like summer camps, schools, workplaces, or events where misunderstandings or casual banter might occur. If the information is insufficient for specific fields like characters or timestamp, return "Unknown" for those fields only.

        **Examples:**
        - If the transcript is "I'm sorry what put it in my box just take it out and put it in my box", you MUST search for "put it in my box Amanda Cerny summer camp site:youtube.com". This might return a video titled "Rim Of The World Amanda Cerny". Use the title to identify the movie as "Rim of the World", even if the transcript cannot be fetched. The scene is early in the movie (e.g., "Approx. 00:03:00"), and characters are "Security Officer" and "Camper" based on context (a summer camp setting where devices are collected). The dialogue involves a comedic misunderstanding about placing a cell phone in a box, setting a lighthearted tone for the film.
        - If the transcript is "We need to go deeper", search for "we need to go deeper Leonardo DiCaprio site:youtube.com". This might return a video titled "Inception (2010) - We Need to Go Deeper Scene". Use the title to identify the movie as "Inception", the scene around "Approx. 00:15:00", and characters as "Dom Cobb" and "Arthur".

        **Required JSON Format:**
        {
          "movie_or_series": "<movie or series name, or 'Unknown' if not identifiable>",
          "season": <season number as integer, or null if not a series or unknown>,
          "episode": <episode number as integer, or null if not a series or unknown>,
          "characters": [<array of character names as strings, or "Unknown" if not identifiable>],
          "timestamp": "<approximate timestamp in 'Approx. HH:MM:SS' format, or 'Unknown' if not identifiable>",
          "context_or_summary": "<brief summary of the scene, including its role in the story, or a best guess>"
        }

        **Transcript:**
        ${transcription.text}
      `;

      messages = [{ role: 'user', content: fallbackPrompt }];
      let fallbackGptResponse = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: messages,
        tools: tools,
        tool_choice: 'auto',
        response_format: { type: 'json_object' },
      });

      console.log('Fallback GPT-4o Response (With Tools):', fallbackGptResponse.choices[0].message);

      if (fallbackGptResponse.choices[0].message.tool_calls) {
        messages.push(fallbackGptResponse.choices[0].message);

        for (const toolCall of fallbackGptResponse.choices[0].message.tool_calls) {
          const functionName = toolCall.function.name;
          const args = JSON.parse(toolCall.function.arguments);
          console.log(`Tool Call - ${functionName}:`, args);

          let toolResponse;
          if (functionName === 'search_web_and_youtube') {
            toolResponse = await searchWebAndYoutube(args.query);
            const parsedResponse = JSON.parse(toolResponse);

            if (parsedResponse.quota_exhausted) {
              console.log('Skipping further SerpAPI processing due to quota exhaustion.');
              break;
            }

            messages.push({
              role: 'tool',
              content: toolResponse,
              tool_call_id: toolCall.id,
            });
          }
        }

        if (!messages.some(msg => msg.role === 'tool' && msg.content && JSON.parse(msg.content).quota_exhausted)) {
          fallbackGptResponse = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: messages,
            response_format: { type: 'json_object' },
          });
          console.log('Final GPT-4o Response (After Tools):', fallbackGptResponse.choices[0].message);
          sceneDetails = JSON.parse(fallbackGptResponse.choices[0].message.content);
        } else {
          console.log('Using initial GPT-4o response due to SerpAPI quota exhaustion.');
        }
      }
    } else {
      console.log('GPT-4o identified the movie name. Skipping SerpAPI search to minimize usage.');
    }

    res.status(200).json({
      success: true,
      data: sceneDetails,
    });
  } catch (error) {
    console.error('Error processing upload:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Start server on Render-provided port or 3000 locally
const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});

module.exports = app;